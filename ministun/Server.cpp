#include <ministun/Server.h>
#include <ministun/Header.h>
#include <ministun/Types.h>
#include <ministun/Utils.h>

using namespace seastar;

namespace ms {
  Server::Server() : state_{State::Stopped} {
    metrics_.add_group("server", {
        metrics::make_derive("protocol", [this] { return Utils::to_underlying(config_.socket->protocol()); },
                             metrics::description{"Protocol"}),
        metrics::make_derive("state", [this] { return Utils::to_underlying(state_); },
                             metrics::description{"Server state"}),
        metrics::make_derive("socket_state", [this] { return Utils::to_underlying(config_.socket->state()); },
                             metrics::description{"Socket state"}),
        metrics::make_derive("socket_accepting", [this] { return config_.socket->accepting(); },
                             metrics::description{"Is socket accepting new connections"}),
        metrics::make_derive("accepted_connections", [this] { return config_.socket->accepted_connections(); },
                             metrics::description{"Connections accepted per day"}),
        metrics::make_derive("valid_stun_connections", [this] { return config_.socket->valid_stun_connections(); },
                             metrics::description{"Valid STUN connections accepted per day"}),
        metrics::make_derive("ongoing_connections", [this] { return config_.socket->ongoing_connections(); },
                             metrics::description{"Ongoing connections"})
    });
  }

  bool Server::start(ServerConfig config) {
    if (state_ != State::Stopped) return false;

    config_ = std::move(config);
    BOOST_ASSERT(config_.socket);

    if (!config_.socket->start(this)) {
      MS_ERROR("Failed to accept");
      return false;
    }

    state_ = State::Started;
    MS_INFO("Started {} server {}", config_.socket->protocol(), config_.socket->local_address());

    return true;
  }

  future<> Server::stop() {
    if (state_ != State::Started) return make_ready_future<>();

    state_ = State::Stopping;

    return config_.socket->stop().then([this] {
      state_ = State::Stopped;
      MS_INFO("Stopped {} server {}", config_.socket->protocol(), config_.socket->local_address());
    });
  }

  future<std::optional<Server::Response>> Server::process_request(
      const shared_ptr<Connection> &conn,
      const MessageBufferReader &request_reader, const Message &request) const {
    BOOST_ASSERT(request.cls() == Class::Request);
    if (request.method() != Method::Binding) return make_ready_future<std::optional<Server::Response>>();

    return futurize_invoke([this, conn, &request_reader, &request] {
      if (!config_.authenticator) return make_ready_future<shared_ptr<AuthResult>>();

      const AuthInput input = {
          .remote_address = conn->remote_address(),
          .request_reader = request_reader,
          .request = request
      };

      return do_with(AuthInput{input}, [this](const AuthInput &input) {
        return config_.authenticator->check(input).then([](shared_ptr<AuthResult> result) {
          BOOST_ASSERT(result);
          return result;
        });
      });
    }).then([conn, &request](const shared_ptr<AuthResult> &result) {
      if (result && result->type() == AuthResult::Type::Error) {
        Message error_message{Header{Method::Binding, Class::ErrorResponse, request.id()}};

        const auto error_result = dynamic_pointer_cast<ErrorAuthResult>(result);
        for (const auto &attribute: error_result->attributes()) {
          BOOST_ASSERT(attribute);
          error_message.add(attribute);
        }

        Response response = {
            .message = std::move(error_message),
            .key = {}
        };
        return std::make_optional(std::move(response));
      }

      /* Any message generated by a server to a request that contains a MESSAGE-INTEGRITY-SHA256 attribute MUST include
       * the MESSAGE-INTEGRITY-SHA256 attribute, computed using the password utilized to authenticate the request.
       * Any message generated by a server to a request that contains only a MESSAGE-INTEGRITY attribute MUST include
       * the MESSAGE-INTEGRITY attribute, computed using the password utilized to authenticate the request. This means
       * that only one of these attributes can appear in a message. The message MUST NOT contain the USERNAME
       * attribute.
       * */
      Message success_message{Header{Method::Binding, Class::SuccessResponse, request.id()}};
      success_message.add(make_shared<XorMappedAddressAttribute>(conn->remote_address()));

      std::optional<std::vector<char>> key;
      if (result) {
        const auto success_result = dynamic_pointer_cast<SuccessAuthResult>(result);

        key = success_result->key();
        if (success_result->algorithm() == IntegrityAlgorithm::Sha256)
          success_message.add(MessageIntegritySha256Attribute::dummy());
        else success_message.add(MessageIntegrityAttribute::dummy());

        for (const auto &attribute: success_result->attributes()) {
          BOOST_ASSERT(attribute);
          success_message.add(attribute);
        }
      }

      Response response = {
          .message = std::move(success_message),
          .key = std::move(key)
      };
      return std::make_optional(std::move(response));
    });
  }
}
